function[ par ] = updateSIG( D, par, priors, info )

par = updateSIGscaleHYP( D, par, priors, info );
expect = getExpectations( par );

par.SIGshape = priors.SIGshape + repmat(info.Tmax,1,info.nclus)/2;

tempsum = repmat(0,1,info.nclus);
for i = 1:info.nclus
    temp = repmat(0,6,info.Tmax+1);
    for tind = 2:(info.Tmax+1)
        %%tind = t+1;
        expFsq = par.Fmean(i,tind)^2 + 1/par.Fprec{tind}(i,i);

	%% calculate the expectation of *SF(t-1)*
	Fvec = par.Fmean(:,tind-1);
	Fprec = par.Fprec{tind-1};
	Svec = par.Smean(i,:);
	Svec(Svec==0) = 0; % I don't know why this helps, but otherwise there could be Inf entries in Svec'*Svec
	Sprec = par.Sprec{i};
	expSF = Svec*Fvec;
	%% simplecovs = (Fvec*Fvec' + pinv(Fprec)) ...
	%%     .* (Svec'*Svec + pinv(Sprec)) ...
	%%     - (Fvec.*Svec') * (Fvec'.*Svec);
	%% varSF = sum(sum(simplecovs));
	%% expSFsq = expSF^2 + varSF;
	expStS = Svec'*Svec + pinv(Sprec);
	expSFsq = Fvec'*expStS*Fvec + trace(expStS / Fprec);

        expSconstSq = par.Sconstmean(i)^2 + 1./par.Sconstprec(i);
        expFtSF = par.Fmean(i,tind) * par.Smean(i,:) * par.Fmean(:,tind-1);
        expFtSconst = par.Fmean(i,tind) * par.Sconstmean(i);
        expSFSconst = par.Smean(i,:)*par.Fmean(:,tind-1) * par.Sconstmean(i);
        
        % save the elements of the sum into a column for each t; adding up
        % similar numbers first helps avoid rounding errors; we later sum
        % the columns first and then the rows
        temp(:,tind) = [ expFsq; expSFsq; expSconstSq; -2*expFtSF; -2*expFtSconst; 2*expSFSconst ];
    end
    
    tempsum(i) = sum(sum(temp,1));

    if(tempsum(i)<0)
      temp
      sum(temp,1)
      tempsum(i) = 1e-10
    end
end
par.SIGscale = expect.SIGscaleHYP + 0.5 * tempsum;

expect = getExpectations( par );
if( sum(sum(expect.SIG<0)) > 0 ) 
  %%par.Smean
  %%par.Sprec
  %%par.Fmean
  %%par.Fprec
  expect.SIG
  expect.SIGscaleHYP
  error('something in expect.SIG is negative')
end


end