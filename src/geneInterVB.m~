addpath('~/fat/research/boku/psykacek/public/mlbsrc/slide_normalization')
addpath('~/fat/research/boku/AmpliMethods')
addpath('~/fat/research/boku/src/matlab')

warning ("off", "Octave:matlab-incompatible");

%% [H, rawD] = scan_fspma('/bi/home/bgodsey/camda2008/printDataMatrix.tsv');
%% rawD( rawD<=0 ) = min(min( rawD(rawD>0) ))/2;
%% D = log( rawD(:,1:1000) );
%% % clusternumbers = 10;


%% the model always starts with t=0. If you want a prior state on the first time
%% point, start the data at t=1. If the data starts at t=0, there are simply
%% fixed weakly informative priors on time point t=0. Starting with data at
%% t=0 seems to work better
%%timeORIG = [ 0:7 0:7 0:7 ];
%% %timeORIG = [ 0 0.5 1.5 3 6 9 12 24 0 0.5 1.5 3 6 9 12 24 0 0.5 1.5 3 6 9 12 24 ];

exper = repmat( 1, 1, 24 );
names = { 'apoptosis' };

%% simdata;
simulateRAFpathway;

timeORIG = repmat( 0:(size(simF,2)-1), 1, numreps );

%% cut out some time points
% ind = timeORIG~=13 & timeORIG~=14;
% timeORIG = timeORIG(ind);
%%D = D(ind,:);

figure; plot(simF(:,unique(timeORIG)+1)'); title('Simulated Data');
%%print -depsc 

%%D = normalizeData(D,length(info.tuniq));
info = setinfo(D,timeORIG,exper,names);

%% Does the model fitting for various cluster numbers
clusternumbers = [ 9 11 13 ];
numstarts = 1;
%%hyperparvals = 0.0001; %(1:20:200) / ( max(max(D))-min(min(D)) );
llh = repmat( -1e20, numstarts, size(clusternumbers,2) );
for i = 1:size(clusternumbers,2)
  nclus = clusternumbers(i);
  nclus
  %% save nclus.out nclus -ascii -tabs

  info.nclus = nclus;
  priors = setpriors( D, info );
  %%par = priors;
  %%expect = getExpectations( par );

  for j = 1:numstarts
    [ allpars{j,i} allpriors{j,i} llh(j,i) iter ] = vbmodelfit( D, priors, info );
  end
end

par = allpars{ find( llh==max(max(llh)) ) };
priors = allpriors{ find( llh==max(max(llh)) ) };

%% par = allpars{ 3 };
% priors = allpriors{ 3 };

%% figure; plot(hyperparvals',llh);
%% legend(num2str(clusternumbers'));
%% title('Log likelihoods for various hyperparameter values');
%% 
%% figure; plot(hyperparvals',llh(:,1:3));
%% legend(num2str(clusternumbers(1:3)'));
%% title('Subset of log likelihoods for various hyperparameter values');

sortllh = sort(llh,'descend');
bestllh = [];
if(size(clusternumbers,2)>1)
  for i = 1:min(10,size(clusternumbers,2))
    matches = find(llh == sortllh(i) );
    bestllh(i) = matches(1);
  end
end

%% save bestllh.out bestllh -ASCII -tabs
%% save llh.out llh -ASCII -tabs

%% save parSmean.out par.Smean -ASCII -tabs
%% for i = 1:nclusopt
%%     save strcat('parSprec', num2str(i), '.out') par.Smean{i} -ASCII -tabs
%% end
%% save parFmean.out par.Fmean -ASCII -tabs


expect = getExpectations( par );

figure; plot(par.Fmean(:,unique(timeORIG)+1)'); title('Inferred Fmeans');
figure; plot(par.mumean); title('Inferred mu means');

postD = par.Fmean(:,1);
for i = 2:timepoints
  %postD = [ postD par.Smean*par.Fmean(:,i-1)+par.Sconstmean ];
  postD = [ postD par.Smean*postD(:,i-1)+par.Sconstmean ];
end
figure; plot(postD(:,unique(timeORIG)+1)'); title('Inferred Dynamics using S and par.Fmean(:,1)');


%% evaluate sensitivity and specificity
simints = getInteractionSignificance( simSmat, 0, simMship );
[ inferredints Ssigs ] = getInteractionSignificance( par.Smean, par.Sprec, par.mship );

threshes = quantile(reshape(inferredints,[],1),(0:1000)/1000);
rocpts = [];
for i = 1:length(threshes) 
  rocpts(i,1) = 1 - sum(sum( ~simints & ~(inferredints>threshes(i))) )/sum(sum(~simints));
  if sum(sum(simints)) > 0
    rocpts(i,2) = sum(sum( simints & (inferredints>threshes(i))) )/sum(sum(simints));
  else
    rocpts(i,2) = 0;
  end
end
%% rocpts = [ rocpts; 1 1 ];

figure; plot(rocpts(:,1),rocpts(:,2)); axis([0, 1, 0, 1],'manual');

auroc = trapz(rocpts(:,1)',rocpts(:,2)');

%% max(max(par.Sprec{2}))

%% if( size(simF) == size(par.Fmean) )
%%     [ ab ind ] = sort(par.Fmean(:,1));
%%     sortedF = par.Fmean(ind,:);
%%     sortedPostD = postD(ind,:);
%%     [ ab ind ] = sort(simF(:,1));
%%     sortedPreD = simF(ind,:);
%%     sortedF - sortedPreD
%%     sortedPostD - sortedPreD
%% 
%%     [ ab ind ] = sort(diag(par.Smean));
%%     sortedS = par.Smean(ind,ind);
%%     [ ab ind ] = sort(diag(Smat));
%%     sortedSmat = Smat(ind,ind);
%%     sortedS - sortedSmat
%% end

